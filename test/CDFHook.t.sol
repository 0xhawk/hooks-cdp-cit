// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import {Deployers} from "@uniswap/v4-core/test/utils/Deployers.sol";
import {LiquidityAmounts} from "@uniswap/v4-core/test/utils/LiquidityAmounts.sol";
import {PoolSwapTest} from "@uniswap/v4-core/src/test/PoolSwapTest.sol";
import "../src/CryptoIndexToken.sol";
import "../src/CDPManager.sol";
import "../src/CDPHook.sol";
import "v4-core/PoolManager.sol";
import "v4-core/interfaces/IPoolManager.sol";
import "v4-core/types/Currency.sol";
import "v4-core/types/PoolKey.sol";
import "v4-core/libraries/TickMath.sol";
import "solmate/src/tokens/ERC20.sol";
import "solmate/src/test/utils/mocks/MockERC20.sol";
import "chainlink/contracts/src/v0.8/tests/MockV3Aggregator.sol";
import {Hooks} from "v4-core/libraries/Hooks.sol";
import {TickMath} from "v4-core/libraries/TickMath.sol";
import {SqrtPriceMath} from "v4-core/libraries/SqrtPriceMath.sol";
import {LiquidityAmounts} from "@uniswap/v4-core/test/utils/LiquidityAmounts.sol";
import "forge-std/console.sol";

contract CDPSystemTest is Test, Deployers {
    MockERC20 usdc;
    CryptoIndexToken cit;
    CDPManager cdpManager;
    CDPHook hook;
    IPoolManager.SwapParams swapParams;
    Currency usdcCurrency;
    Currency citCurrency;
    PoolKey poolKey;
    MockV3Aggregator oracle;

    function setUp() public {
        // Deploy Pool Manager using Deployers utility
        deployFreshManagerAndRouters();

        // Deploy USDC Mock Token
        usdc = new MockERC20("Mock USDC", "USDC", 6);
        usdc.mint(address(this), 10_000e6);

        // Approve USDC Mock
        usdc.approve(address(swapRouter), type(uint256).max);
        usdc.approve(address(modifyLiquidityRouter), type(uint256).max);
        usdc.approve(address(hook), type(uint256).max);

        // Deploy Mock Oracle
        oracle = new MockV3Aggregator(18, 1_000e18); // Assume CIT price is $1,000, 18 decimals

        // Deploy Hook
        uint160 flags = uint160(
            Hooks.AFTER_INITIALIZE_FLAG |
                Hooks.BEFORE_ADD_LIQUIDITY_FLAG |
                Hooks.AFTER_SWAP_FLAG
        );
        deployCodeTo("CDPHook.sol", abi.encode(manager), address(flags));
        hook = CDPHook(address(flags));

        // Deploy CDP Manager, pass the hook's address
        cdpManager = new CDPManager(
            address(usdc),
            address(oracle),
            address(hook)
        );
        usdc.approve(address(cdpManager), type(uint256).max);

        // Now set the CDP Manager's address in the Hook
        hook.setCDPManager(address(cdpManager));

        // Predict the CIP token address generated by CREATE2
        bytes32 salt = keccak256(abi.encodePacked("unique_identifier"));
        bytes memory bytecode = type(CryptoIndexToken).creationCode;
        bytes32 bytecodeHash = cdpManager.getBytecodeHash(bytecode);
        address predictedCitAddress = cdpManager.computeAddress(
            salt,
            bytecodeHash
        );
        cit = CryptoIndexToken(predictedCitAddress);

        // Wrap currency for the pool
        usdcCurrency = Currency.wrap(address(usdc));
        citCurrency = Currency.wrap(address(cit));

        // Initialize a pool
        (key, ) = initPool(
            usdcCurrency, // Currency 0 = USDC
            citCurrency, // Currency 1 = CIT
            hook, // Hook Contract
            3000, // Swap Fees
            SQRT_PRICE_1_1 // Initial Sqrt(P) value = 1
        );
        cit.approve(address(swapRouter), type(uint256).max);
        cit.approve(address(modifyLiquidityRouter), type(uint256).max);
        cit.approve(address(hook), type(uint256).max);
    }

    function testAddLiquidity() public {
        // Approve
        usdc.approve(address(hook), type(uint256).max);
        cit.approve(address(hook), type(uint256).max);

        // Execute
        hook.addLiquidity(key, 200e6);

    
        // Get the user's position
        (uint256 collateral, uint256 debt) = cdpManager.positions(
            address(this)
        );
        console.log("Collateral:", collateral);
        console.log("Debt:", debt);

        // Check that collateral and debt are updated
        assertTrue(collateral > 0, "Collateral not updated");
        assertTrue(debt > 0, "Debt not updated");

        // Check balances in the pool
        uint256 poolUsdcBalance = usdc.balanceOf(address(manager));
        uint256 poolCitBalance = cit.balanceOf(address(manager));

        console.log("Pool USDC Balance:", poolUsdcBalance);
        console.log("Pool CIT Balance:", poolCitBalance);

        assertTrue(poolUsdcBalance > 0, "USDC not added to pool");
        assertTrue(poolCitBalance > 0, "CIT not added to pool");

        // TODO: using the price oracle to assert the number exactly
    }

    // function testAddLiquidityMultipleTimes() public {
    //     // Approve
    //     usdc.approve(address(hook), type(uint256).max);
    //     cit.approve(address(hook), type(uint256).max);

    //     // Execute
    //     hook.addLiquidity(key, 200e6); // 200 USDC
    //     hook.addLiquidity(key, 300e6); // 300 USDC
    //     hook.addLiquidity(key, 500e6); // 500 USDC

    //     // TODO
    // }

    // function testSwapUSDCForCIT() public {
    //     // User has USDC and wants to swap for CIT
    //     uint256 usdcAmount = 1_000e6;
    //     usdc.mint(address(this), usdcAmount);
    //     usdc.approve(address(swapRouter), usdcAmount);

    //     // Swap USDC for CIT
    //     IPoolManager.SwapParams memory params = IPoolManager.SwapParams({
    //         zeroForOne: true,
    //         amountSpecified: int256(usdcAmount), // Exact output swap
    //         sqrtPriceLimitX96: TickMath.MIN_SQRT_PRICE + 1
    //     });

    //     swapRouter.swap(
    //         key,
    //         params,
    //         PoolSwapTest.TestSettings({
    //             takeClaims: false,
    //             settleUsingBurn: false
    //         }),
    //         ZERO_BYTES
    //     );

    //     // Check balances
    //     uint256 citBalance = cit.balanceOf(address(this));
    //     assertTrue(citBalance > 0, "Swap failed");
    //     console.log("CIT Balance after swap:", citBalance);
    // }

    // function testSwapCITForUSDC() public {
    //     // TODO
    // }
}
